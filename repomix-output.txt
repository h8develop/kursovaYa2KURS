This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-12T13:52:48.272Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/
  workflows/
    ci-cd.yml
backend/
  app/
    routers/
      ads.py
    metrics.py
    models.py
    schemas.py
  Dockerfile
  main.py
  requirements.txt
frontend/
  public/
    index.html
  src/
    components/
      AdList.js
      Dashboard.js
    App.js
    index.js
  Dockerfile
  package.json
infrastructure/
  grafana/
    grafana.ini
  loki/
    loki-config.yaml
  prometheus/
    prometheus.yml
k8s/
  backend-deployment.yaml
  backend-service.yaml
  db-deployment.yaml
  db-pvc.yaml
  db-service.yaml
  frontend-deployment.yaml
  frontend-service.yaml
  grafana-deployment.yaml
  grafana-pvc.yaml
  grafana-service.yaml
  ingress.yaml
  loki-configmap.yaml
  loki-deployment.yaml
  loki-pvc.yaml
  loki-service.yaml
  prometheus-configmap.yaml
  prometheus-deployment.yaml
  prometheus-service.yaml
  promtail-configmap.yaml
  promtail-deployment.yaml
docker-compose.yml
README.md

================================================================
Repository Files
================================================================

================
File: .github/workflows/ci-cd.yml
================
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]

jobs:
  # Этап 1: Сборка контейнеров
  build:
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Docker Registry
        run: |
          echo ${{ secrets.DOCKERHUB_PASSWORD }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

      - name: Build backend image
        run: |
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/ad-management-system-backend:latest -f backend/Dockerfile .

      - name: Push backend image
        run: |
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/ad-management-system-backend:latest

      - name: Build frontend image
        run: |
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/ad-management-system-frontend:latest -f frontend/Dockerfile .

      - name: Push frontend image
        run: |
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/ad-management-system-frontend:latest

  # Этап 2: Деплой на Kubernetes
  deploy:
    runs-on: self-hosted
    needs: build # Зависимость от этапа "build"
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Kubeconfig from Secret
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" > kubeconfig
          chmod 600 kubeconfig
          export KUBECONFIG=$(pwd)/kubeconfig

      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -f k8s/

================
File: backend/app/routers/ads.py
================
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from app.schemas import AdCreate, AdRead
from app.models import Ad
from app.metrics import ads_created_counter, ad_creation_latency  # Импорт метрик

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql://user:password@db:5432/advertising"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

router = APIRouter()

# Зависимость для получения сессии базы данных
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@router.post("/", response_model=AdRead)
def create_ad(ad: AdCreate, db: Session = Depends(get_db)):
    with ad_creation_latency.time():
        db_ad = Ad(title=ad.title, description=ad.description)
        db.add(db_ad)
        db.commit()
        db.refresh(db_ad)
        ads_created_counter.inc()
        return db_ad

@router.get("/", response_model=list[AdRead])
def read_ads(db: Session = Depends(get_db)):
    ads = db.query(Ad).all()
    return ads

@router.get("/{ad_id}", response_model=AdRead)
def read_ad(ad_id: int, db: Session = Depends(get_db)):
    ad = db.query(Ad).filter(Ad.id == ad_id).first()
    if ad is None:
        raise HTTPException(status_code=404, detail="Ad not found")
    return ad

@router.put("/{ad_id}", response_model=AdRead)
def update_ad(ad_id: int, ad: AdCreate, db: Session = Depends(get_db)):
    db_ad = db.query(Ad).filter(Ad.id == ad_id).first()
    if db_ad is None:
        raise HTTPException(status_code=404, detail="Ad not found")
    db_ad.title = ad.title
    db_ad.description = ad.description
    db.commit()
    db.refresh(db_ad)
    return db_ad

@router.delete("/{ad_id}")
def delete_ad(ad_id: int, db: Session = Depends(get_db)):
    db_ad = db.query(Ad).filter(Ad.id == ad_id).first()
    if db_ad is None:
        raise HTTPException(status_code=404, detail="Ad not found")
    db.delete(db_ad)
    db.commit()
    return {"detail": "Ad deleted"}

================
File: backend/app/metrics.py
================
from prometheus_client import Counter, Histogram

ads_created_counter = Counter(
    'ads_created_total', 
    'Total number of ads created'
)

ad_creation_latency = Histogram(
    'ad_creation_latency_seconds', 
    'Latency for creating an ad'
)

================
File: backend/app/models.py
================
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Ad(Base):
    __tablename__ = "ads"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True, nullable=False)
    description = Column(String, nullable=False)

================
File: backend/app/schemas.py
================
from pydantic import BaseModel

class AdBase(BaseModel):
    title: str
    description: str

class AdCreate(AdBase):
    pass

class AdRead(AdBase):
    id: int

    class Config:
        orm_mode = True

================
File: backend/Dockerfile
================
FROM python:3.9-slim

WORKDIR /app

# Установка зависимостей
COPY backend/requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Копирование кода приложения
COPY backend/ .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

================
File: backend/main.py
================
from fastapi.middleware.cors import CORSMiddleware
from fastapi import FastAPI, Response
from app.routers import ads
from app.models import Base  # Правильный путь
from sqlalchemy import create_engine
from prometheus_client import generate_latest
from app.metrics import ads_created_counter, ad_creation_latency  # Импорт метрик

DATABASE_URL = "postgresql://user:password@db:5432/advertising"
engine = create_engine(DATABASE_URL)
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Ad Management Backend")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://frontend.local"],  # или указать нужные домены
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Подключаем роуты объявлений
app.include_router(ads.router, prefix="/ads", tags=["Ads"])

# Endpoint /metrics
@app.get("/metrics")
def metrics():
    return Response(generate_latest(), media_type="text/plain")

================
File: backend/requirements.txt
================
fastapi
uvicorn[standard]
sqlalchemy
psycopg2-binary
pydantic==1.10.12
prometheus_client

================
File: frontend/public/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Management system</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>

================
File: frontend/src/components/AdList.js
================
import React from 'react';

function AdList({ ads, deleteAd }) {
  return (
    <div>
      <h2>Список объявлений</h2>
      {ads.length === 0 ? (
        <p>Нет объявлений.</p>
      ) : (
        <ul>
          {ads.map(ad => (
            <li key={ad.id} style={{ marginBottom: '10px' }}>
              <strong>{ad.title}</strong>: {ad.description}
              <button
                onClick={() => deleteAd(ad.id)}
                style={{ marginLeft: '10px' }}
              >
                Удалить
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

export default AdList;

================
File: frontend/src/components/Dashboard.js
================
import React from 'react';

function Dashboard() {
return (
<div>
    <h2>Analytics Dashboard</h2>
    <iframe src="http://grafana.local/public-dashboards/88a41d22e115470eb2451314d96643fd" width="450" height="200" frameborder="0"></iframe>
</div>
);
}

export default Dashboard;

================
File: frontend/src/App.js
================
import React, { useState, useEffect } from 'react';
import AdList from './components/AdList';
import axios from 'axios';
import { BrowserRouter as Router, Route, Link, Routes } from 'react-router-dom';
import Dashboard from './components/Dashboard';

axios.defaults.baseURL = 'http://backend.local';

function App() {
  const [ads, setAds] = useState([]);
  const [title, setTitle] = useState('');
  const [description, setDescription] = useState('');

  useEffect(() => {
    fetchAds();
  }, []);

  const fetchAds = async () => {
    try {
      const response = await axios.get('/ads/');
      setAds(response.data);
    } catch (error) {
      console.error('Ошибка при получении объявлений:', error);
    }
  };

  const createAd = async () => {
    try {
      const response = await axios.post('/ads/', { title, description });
      setAds([...ads, response.data]);
      setTitle('');
      setDescription('');
    } catch (error) {
      console.error('Ошибка при создании объявления:', error);
    }
  };

  const deleteAd = async (id) => {
    try {
      await axios.delete(`/ads/${id}`);
      setAds(ads.filter(ad => ad.id !== id));
    } catch (error) {
      console.error('Ошибка при удалении объявления:', error);
    }
  };

  return (
    <Router basename="/">
      <div style={{ padding: '20px' }}>
        <h1>Система управления рекламными кампаниями</h1>
        <nav style={{ marginBottom: '20px' }}>
          <Link to="/" style={{ marginRight: '20px' }}>Главная</Link>
          <Link to="/dashboard">Аналитика</Link>
        </nav>
        <Routes>
          <Route 
            path="/" 
            element={
              <>
                <h2>Создать объявление</h2>
                <input
                  type="text"
                  placeholder="Название"
                  value={title}
                  onChange={e => setTitle(e.target.value)}
                  style={{ marginRight: '10px' }}
                />
                <input
                  type="text"
                  placeholder="Описание"
                  value={description}
                  onChange={e => setDescription(e.target.value)}
                  style={{ marginRight: '10px' }}
                />
                <button onClick={createAd}>Создать</button>
                <AdList ads={ads} deleteAd={deleteAd} />
              </>
            }
          />
          <Route path="/dashboard" element={<Dashboard />} />
        </Routes>
      </div>
    </Router>
  );
}

export default App;

================
File: frontend/src/index.js
================
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);

================
File: frontend/Dockerfile
================
# Этап сборки
FROM node:16-alpine AS build

WORKDIR /app

COPY frontend/package.json frontend/yarn.lock ./
RUN yarn install

COPY . .
RUN yarn build

# Этап сервировки с помощью Nginx
FROM nginx:alpine

COPY --from=build /app/build /usr/share/nginx/html

# Добавление настройки для маршрутов React
RUN echo 'server {\n\
    listen 80;\n\
    server_name localhost;\n\
\n\
    location / {\n\
        root /usr/share/nginx/html;\n\
        index index.html;\n\
        try_files $uri /index.html;\n\
    }\n\
}' > /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]

================
File: frontend/package.json
================
{
    "name": "ad-management-frontend",
    "version": "1.0.0",
    "private": true,
    "dependencies": {
      "react": "^18.2.0",
      "react-dom": "^18.2.0",
      "react-scripts": "5.0.1",
      "axios": "^1.4.0",
      "react-router-dom": "^6.14.2"
    },
    "scripts": {
      "start": "react-scripts start",
      "build": "react-scripts build"
    }
  }

================
File: infrastructure/grafana/grafana.ini
================
# Пример конфигурации Grafana (опционально)

[server]
# Protocol (http, https)
protocol = http

# The http port to use
http_port = 3000

[security]
# Set admin password
admin_password = admin

# Disable anonymous access
allow_anonymous = false

[security]
allow_embedding = true

================
File: infrastructure/loki/loki-config.yaml
================
auth_enabled: false

server:
  http_listen_port: 3100

ingester:
  lifecycler:
    address: 127.0.0.1
    ring:
      kvstore:
        store: inmemory
      replication_factor: 1
  chunk_idle_period: 5m
  chunk_target_size: 1048576
  chunk_retain_period: 30s
  max_transfer_retries: 0

schema_config:
  configs:
    - from: 2020-10-24
      store: boltdb-shipper
      object_store: filesystem
      schema: v11
      index:
        prefix: index_
        period: 24h

storage_config:
  boltdb_shipper:
    active_index_directory: /tmp/loki/index
    cache_location: /tmp/loki/cache
    shared_store: filesystem
  filesystem:
    directory: /tmp/loki/chunks


limits_config:
  enforce_metric_name: false
  reject_old_samples: true
  reject_old_samples_max_age: 168h

================
File: infrastructure/prometheus/prometheus.yml
================
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'frontend'
    static_configs:
      - targets: ['frontend:80']

  - job_name: 'backend'
    metrics_path: /metrics
    static_configs:
      - targets: ['backend:8000']

  - job_name: 'postgresql'
    static_configs:
      - targets: ['db:5432']

================
File: k8s/backend-deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
        - name: backend
          image: nedavi/ad-management-system-backend:latest
          ports:
            - containerPort: 8000
          env:
            - name: DATABASE_URL
              value: "postgresql://user:password@db:5432/advertising"
          readinessProbe:
            httpGet:
              path: "/ads/"
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: "/ads/"
              port: 8000
            initialDelaySeconds: 15
            periodSeconds: 20

================
File: k8s/backend-service.yaml
================
apiVersion: v1
kind: Service
metadata:
  name: backend
spec:
  type: ClusterIP
  selector:
    app: backend
  ports:
    - protocol: TCP
      port: 8000
      targetPort: 8000

================
File: k8s/db-deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: db
spec:
  replicas: 1
  selector:
    matchLabels:
      app: db
  template:
    metadata:
      labels:
        app: db
    spec:
      containers:
        - name: db
          image: postgres:13
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_USER
              value: "user"
            - name: POSTGRES_PASSWORD
              value: "password"
            - name: POSTGRES_DB
              value: "advertising"
          volumeMounts:
            - name: db-data
              mountPath: /var/lib/postgresql/data
          readinessProbe:
            exec:
              command: ["pg_isready", "-U", "user"]
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            exec:
              command: ["pg_isready", "-U", "user"]
            initialDelaySeconds: 15
            periodSeconds: 20
      volumes:
        - name: db-data
          persistentVolumeClaim:
            claimName: db-pvc

================
File: k8s/db-pvc.yaml
================
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: db-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi

================
File: k8s/db-service.yaml
================
apiVersion: v1
kind: Service
metadata:
  name: db
spec:
  type: ClusterIP
  selector:
    app: db
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432

================
File: k8s/frontend-deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
        - name: frontend
          image: nedavi/ad-management-system-frontend:latest
          ports:
            - containerPort: 80
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 15
            periodSeconds: 20

================
File: k8s/frontend-service.yaml
================
apiVersion: v1
kind: Service
metadata:
  name: frontend
spec:
  type: ClusterIP
  selector:
    app: frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80

================
File: k8s/grafana-deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
        - name: grafana
          image: grafana/grafana
          ports:
            - containerPort: 3000
          env:
            - name: GF_SECURITY_ADMIN_PASSWORD
              value: "admin"  # Устанавливаем пароль администратора
          volumeMounts:
            - name: grafana-storage
              mountPath: /var/lib/grafana
          readinessProbe:
            httpGet:
              path: "/api/health"
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: "/api/health"
              port: 3000
            initialDelaySeconds: 15
            periodSeconds: 20
      volumes:
        - name: grafana-storage
          persistentVolumeClaim:
            claimName: grafana-pvc

================
File: k8s/grafana-pvc.yaml
================
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: grafana-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi

================
File: k8s/grafana-service.yaml
================
apiVersion: v1
kind: Service
metadata:
  name: grafana
spec:
  type: ClusterIP
  selector:
    app: grafana
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000

================
File: k8s/ingress.yaml
================
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ad-management-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
    - host: frontend.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: frontend
                port:
                  number: 80
    - host: backend.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: backend
                port:
                  number: 8000
    - host: grafana.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: grafana
                port:
                  number: 3000
    - host: prometheus.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: prometheus
                port:
                  number: 9090
    - host: loki.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: loki
                port:
                  number: 3100

================
File: k8s/loki-configmap.yaml
================
apiVersion: v1
kind: ConfigMap
metadata:
  name: loki-configmap
data:
  loki-config.yaml: |
    auth_enabled: false

    server:
      http_listen_port: 3100

    distributor:
      ring:
        kvstore:
          store: inmemory

    ingester:
      lifecycler:
        address: 127.0.0.1
        ring:
          kvstore:
            store: inmemory
        final_sleep: 0s

    limits_config:
      reject_old_samples: true
      reject_old_samples_max_age: 168h

    schema_config:
      configs:
        - from: 2020-10-24
          store: boltdb-shipper
          object_store: filesystem
          schema: v11
          index:
            prefix: index_
            period: 24h

    storage_config:
      boltdb_shipper:
        active_index_directory: /var/loki/index
        shared_store: filesystem
      filesystem:
        directory: /var/loki/chunks

    querier:
      query_ingesters_within: 2h

================
File: k8s/loki-deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: loki
spec:
  replicas: 1
  selector:
    matchLabels:
      app: loki
  template:
    metadata:
      labels:
        app: loki
    spec:
      securityContext:
        fsGroup: 1000
      initContainers:
        - name: init-permissions
          image: busybox:latest
          command: ["/bin/sh", "-c"]
          args: ["mkdir -p /tmp/loki/index /tmp/loki/chunks /tmp/loki/cache && chmod -R 777 /tmp/loki"]
          volumeMounts:
            - name: loki-data
              mountPath: /tmp/loki
      containers:
        - name: loki
          image: grafana/loki:2.7.1
          args:
            - "-config.file=/etc/loki/loki-config.yaml"
          ports:
            - containerPort: 3100
          volumeMounts:
            - name: loki-config
              mountPath: /etc/loki/loki-config.yaml
              subPath: loki-config.yaml
            - name: loki-data
              mountPath: /tmp/loki
          readinessProbe:
            httpGet:
              path: /ready
              port: 3100
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /ready
              port: 3100
            initialDelaySeconds: 15
            periodSeconds: 20
      volumes:
        - name: loki-config
          configMap:
            name: loki-configmap
        - name: loki-data
          hostPath:
            path: /tmp/loki
            type: DirectoryOrCreate

================
File: k8s/loki-pvc.yaml
================
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: loki-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi

================
File: k8s/loki-service.yaml
================
apiVersion: v1
kind: Service
metadata:
  name: loki
spec:
  type: ClusterIP
  selector:
    app: loki
  ports:
    - protocol: TCP
      port: 3100
      targetPort: 3100

================
File: k8s/prometheus-configmap.yaml
================
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-configmap
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s

    scrape_configs:
      - job_name: 'frontend'
        static_configs:
          - targets: ['frontend:80']

      - job_name: 'backend'
        static_configs:
          - targets: ['backend:8000']

      - job_name: 'postgresql'
        static_configs:
          - targets: ['db:5432']

================
File: k8s/prometheus-deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
        - name: prometheus
          image: prom/prometheus
          ports:
            - containerPort: 9090
          volumeMounts:
            - name: prometheus-config
              mountPath: /etc/prometheus/prometheus.yml
              subPath: prometheus.yml
          args:
            - "--config.file=/etc/prometheus/prometheus.yml"
          readinessProbe:
            httpGet:
              path: "/-/ready"
              port: 9090
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: "/-/healthy"
              port: 9090
            initialDelaySeconds: 15
            periodSeconds: 20
      volumes:
        - name: prometheus-config
          configMap:
            name: prometheus-configmap

================
File: k8s/prometheus-service.yaml
================
apiVersion: v1
kind: Service
metadata:
  name: prometheus
spec:
  type: ClusterIP
  selector:
    app: prometheus
  ports:
    - protocol: TCP
      port: 9090
      targetPort: 9090

================
File: k8s/promtail-configmap.yaml
================
apiVersion: v1
kind: ConfigMap
metadata:
  name: promtail-configmap
data:
  promtail.yaml: |
    server:
      http_listen_port: 9080
      grpc_listen_port: 0

    positions:
      filename: /tmp/positions.yaml

    clients:
      - url: http://loki:3100/loki/api/v1/push

    scrape_configs:
      - job_name: kubernetes-pods
        kubernetes_sd_configs:
          - role: pod
        relabel_configs:
          - source_labels: [__meta_kubernetes_pod_label_app]
            action: keep
            regex: frontend|backend|db|prometheus|grafana|loki
          - source_labels: [__meta_kubernetes_namespace]
            target_label: namespace
          - source_labels: [__meta_kubernetes_pod_name]
            target_label: pod
          - source_labels: [__meta_kubernetes_pod_container_name]
            target_label: container
        pipeline_stages:
          - json:
              expressions:
                level: level
                msg: msg
          - labels:
              level:
          - multiline:
              firstline: '^\S'
              max_wait_time: 3s

================
File: k8s/promtail-deployment.yaml
================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: promtail
spec:
  replicas: 1
  selector:
    matchLabels:
      app: promtail
  template:
    metadata:
      labels:
        app: promtail
    spec:
      containers:
        - name: promtail
          image: grafana/promtail:2.7.1
          args:
            - "-config.file=/etc/promtail/promtail.yaml"
          volumeMounts:
            - name: promtail-config
              mountPath: /etc/promtail/promtail.yaml
              subPath: promtail.yaml
            - name: var-log
              mountPath: /var/log
      volumes:
        - name: promtail-config
          configMap:
            name: promtail-configmap
        - name: var-log
          hostPath:
            path: /var/log

================
File: docker-compose.yml
================
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "3000:80"  # Frontend доступен на http://localhost:3000
    depends_on:
      - backend
    networks:
      - app-network

  backend:
    build: ./backend
    ports:
      - "8000:8000"  # Backend доступен на http://localhost:8000
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/advertising
    depends_on:
      - db
    networks:
      - app-network

  db:
    image: postgres:13
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: advertising
    volumes:
      - db-data:/var/lib/postgresql/data
    ports:
      - "5432:5432"  # База данных доступна на localhost:5432
    networks:
      - app-network

  prometheus:
    image: prom/prometheus
    volumes:
      - ./infrastructure/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"  # Prometheus доступен на http://localhost:9090
    networks:
      - app-network

  grafana:
    image: grafana/grafana
    ports:
      - "3001:3000"  # Grafana доступна на http://localhost:3001
    depends_on:
      - prometheus
      - loki
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin  # Устанавливаем пароль администратора
    networks:
      - app-network

  loki:
    image: grafana/loki:2.7.1
    ports:
      - "3100:3100"  # Loki доступна на http://localhost:3100
    volumes:
      - ./infrastructure/loki/loki-config.yaml:/etc/loki/loki-config.yaml
      - loki-data:/var/loki
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  db-data:
  loki-data:

================
File: README.md
================
# Ad Management System

Система управления рекламными кампаниями с кластерной архитектурой на Kubernetes и CI/CD с использованием GitHub Actions.

## **Структура Проекта**


## **Компоненты**

- **Frontend**: React приложение, обслуживаемое через Nginx.
- **Backend**: FastAPI приложение для обработки API запросов.
- **PostgreSQL**: База данных для хранения данных рекламных кампаний.
- **Prometheus**: Система мониторинга.
- **Grafana**: Платформа для визуализации метрик и логов.
- **Loki**: Система логирования.
- **Ingress Controller**: Управляет внешним доступом к сервисам.

## **Требования**

- Docker и Docker Compose (для локальной разработки).
- Kubernetes кластер (локально с Minikube или в облаке).
- kubectl установлен и настроен для взаимодействия с вашим кластером.
- GitHub репозиторий с настройками CI/CD.

## **Локальная Разработка с Docker Compose**

### **Шаг 1: Сборка и Запуск Контейнеров**

```bash
docker-compose up --build -d
